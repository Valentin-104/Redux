---
title: ë¬´í•œ ìŠ¤í¬ë¡¤
date: '2023-03-17'
tags: ['Intersection Observer', 'ChatGPT']
draft: false
summary: ChatGPTê°€ ì•Œë ¤ì£¼ëŠ” ë¬´í•œ ìŠ¤í¬ë¡¤
---

- ë¬´í•œ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ì„ êµ¬í˜„í•˜ê³  ì‹¶ì—ˆë‹¤. êµ¬ê¸€ë§ì„ í†µí•´ ì ìš©í•  ë§Œí•œ ì½”ë“œë¥¼ ì°¾ì•˜ë‹¤.
    
  > [ì‹¤ì „ Infinite Scroll with React](https://tech.kakaoenterprise.com/149)
    
- ì´ ì½”ë“œë¥¼ ì°¸ê³ í•´ ì‘ì„±í•œ ì²« ë²ˆì§¸ ì½”ë“œ.

  ```tsx
  import { useState, useRef, useEffect, useCallback } from 'react';
  import { imgUrl, requests } from './api/requests';
  import { Movie } from '.';
  import { axiosInstance } from './api/axios';
  import { AxiosError } from 'axios';
  
  export default function Upcoming() {
    const [movies, setMovies] = useState<Movie[]>([]);
    const [page, setPage] = useState<number>(1);
  	const endPoint = requests.upComing;
  
    useEffect(() => {
      const fetchMovies = async () => {
        try {
          const res = await axiosInstance.get(`${endPoint}?page=${page}`);
          const newMovies = res.data.results;
  
          setMovies((prevMovies) => [...prevMovies, ...newMovies]);
        } catch (error) {
          const err = error as AxiosError;
          console.log(err.response?.data);
        }
      };
  
      fetchMovies();
    }, [page]);
  
    const ref = useRef<HTMLDivElement>(null);
    const callback = useCallback(
      (entries: IntersectionObserverEntry[]) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            setPage((prevPage) => prevPage + 1);
          }
        });
      },
      [setPage]
    );
  
    useEffect(() => {
      if (!ref.current) return;
  
      const observer = new IntersectionObserver(callback);
      observer.observe(ref.current);
  
      return () => observer.disconnect();
    }, [callback]);
  
    return (
     <div className='space-y-3 p-8 bg-black'>
        <h1 className='text-white text-base md:text-2xl font-bold'>
          Upcoming Movies
        </h1>
        <div className='grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3'>
          {movies.map((movie, idx) => (
            <div key={idx} className='relative group cursor-pointer'>
              <img
                src={`${imgUrl}/w500${movie.backdrop_path || movie.poster_path}`}
                alt='Thumbnail'
                className='object-cover w-full rounded-md group-hover:opacity-50'
              />
              <h3 className='title opacity-0 group-hover:opacity-100 text-center absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10 text-white font-bold'>
                {movie.title || movie.name}
              </h3>
            </div>
          ))}
          <div ref={ref} className='h-[1px]' />
        </div>
      </div>
    );
  }
  ```

- ì´ ì½”ë“œì˜ ë¬¸ì œì ì€ 

  1. ì²˜ìŒì— í˜ì´ì§€ê°€ ë¡œë“œë  ë•Œ TMDB APIë¡œë¶€í„° 20ê°œì˜ ì˜í™”ë§Œ ë¶ˆëŸ¬ì™€ì•¼ í•˜ëŠ”ë° 60ê°œë‚˜ ë¶ˆëŸ¬ì™”ë‹¤.
  2. í˜ì´ì§€ ìµœí•˜ë‹¨ìœ¼ë¡œ ìŠ¤í¬ë¡¤í•˜ë©´ page ìƒíƒœê°€ 1ì”© ì¦ê°€í•˜ë©´ì„œ 20ê°œì˜ ì˜í™”ë§Œ ë¶ˆëŸ¬ì™€ì•¼ í•˜ëŠ”ë°, pageê°€ 2, 3ì”© ì¦ê°€í•˜ë©´ì„œ 40ê°œ, 60ê°œì”© ë¶ˆëŸ¬ì™”ë‹¤.

- ChatGPTì—ê²Œ ë¬¼ì–´ë³´ì•˜ë‹¤. ë¨¼ì € 1ë²ˆì— ëŒ€í•´

  > I want to fetch 20 items every time I scroll to the bottom of the page, but the first time the page loads, it fetches 60 items.

- ê·¸ì˜ ë‹µë³€. 

  > In that case, you can modify your current implementation by setting the initial page state to 0 instead of 1, and updating the fetchMovies function to pass the appropriate page value to the API endpoint. 
  
  pageì˜ ì´ˆê¸° ìƒíƒœë¥¼ 1ì´ ì•„ë‹ˆë¼ 0ìœ¼ë¡œ ì„¤ì •í•˜ë¼ëŠ” ê²ƒì´ì—ˆë‹¤. ë  ë¦¬ê°€ ì—†ë‹¤ê³  ìƒê°í–ˆì§€ë§Œ í˜¹ì‹œë‚˜ í•˜ê³  í•´ë³´ë‹ˆê¹Œ 1ë²ˆì´ í•´ê²°ëë‹¤. ì†”ì§íˆ ì™œ ë˜ëŠ”ì§€ëŠ” ëª¨ë¥´ê² ë‹¤â€¦;; 

  ê·¸ë¦¬ê³  í˜ì´ì§€ í•˜ë‹¨ìœ¼ë¡œ ìŠ¤í¬ë¡¤ í•  ë•Œ, API ìš”ì²­ì´ í•œ ë²ˆì”©ì´ ì•„ë‹ˆë¼ ì—¬ëŸ¬ ë²ˆ ì¼ì–´ë‚˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ë¡œì§ì„ ì¶”ê°€í•˜ë¼ê³  í•˜ì˜€ë‹¤. 2ë²ˆ ì´ìŠˆì— ëŒ€í•œ ì„¤ëª…ì´ë‹¤.

  > Note that you may also want to add some additional logic to prevent multiple API requests from being sent at once or to handle cases where there are no more movies to fetch. 

- ì´ëŸ¬í•œ í˜„ìƒì´ ì¼ì–´ë‚˜ëŠ” ì´ìœ ë¥¼ ë¬¼ì–´ë³´ì•˜ë‹¤.
  > There could be a few reasons why your page state is increasing by more than 1 when you scroll to the bottom of the page.
  > One possibility is that the useEffect hook that updates the page state is triggering multiple times when you reach the bottom of the page. This can happen if the browser's scroll behavior causes the bottom of the page to overshoot the intersection threshold, triggering the observer multiple times. To prevent this, you can add a debounce to your useCallback function that updates the page state, so that it only triggers once every few hundred milliseconds.

- 2ê°€ì§€ í•´ê²°ì±…ì„ ì œì‹œí•˜ì˜€ëŠ”ë°, í•˜ë‚˜ëŠ” `useCallback` Hookì— debounceë¥¼ ì¶”ê°€í•˜ë¼ëŠ” ê²ƒì´ì—ˆê³ , ë‹¤ë¥¸ í•˜ë‚˜ëŠ” intersection observerì— root marginì„ ìŒìˆ˜ê°’ìœ¼ë¡œ ì„¤ì •í•˜ë¼ëŠ” ê²ƒì´ì—ˆë‹¤.

  ë¨¼ì € í•˜ê¸° ì‰¬ìš´ root marginë¶€í„° ì„¤ì •í•´ë³´ì•˜ë‹¤. í•˜ì§€ë§Œ ê²°ê³¼ëŠ” ë˜‘ê°™ì•˜ë‹¤. ê·¸ë˜ì„œ debounceë¥¼ ì–´ë–»ê²Œ ì„¤ì •í•˜ëŠ”ì§€ ë¬¼ì–´ë³´ì•˜ë‹¤.

  > To add a debounce to your useCallback function, you can use the lodash.debounce function from the lodash library.
  > First, install the lodash library by running npm install lodash or yarn add lodash in your project directory.
  > Then, import the debounce function and use it to wrap your setPage function inside a useCallback hook. Here's an example. 

  ```ts
  import debounce from 'lodash.debounce';
  
  const callback = useCallback(
      debounce(
        (entries: IntersectionObserverEntry[]) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              setPage((prevPage) => prevPage + 1);
            }
          });
        },
        500 // set debounce time in milliseconds
      ),
      [setPage]
    );
  ```

- `lodash.debounce`ë¼ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì„¤ì¹˜í•´ì„œ `debounce`ë¼ëŠ” í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ë¼ëŠ” ê²ƒì´ì—ˆë‹¤. ì œì‹œí•œ ì½”ë“œë¥¼ ë³´ë‹ˆê¹Œ,  `debounce`í•¨ìˆ˜ë¡œ `useCallback` Hookì•ˆì˜ `setPage` í•¨ìˆ˜ë¥¼ ê°ì‹¸ì£¼ì—ˆë‹¤.

- ì´ê±¸ ë³´ê³  ê·¸ëŒ€ë¡œ ì ìš©í•´ë³´ì•˜ë‹¤. 2ë²ˆ ì´ìŠˆë„ í•´ê²°ë˜ì—ˆë‹¤.

- ê·¸ëŸ°ë° ë˜ ë‹¤ë¥¸ ë¬¸ì œê°€ ë°œìƒí–ˆë‹¤. ê¸°ëŠ¥ êµ¬í˜„ì—ëŠ” ë¬¸ì œê°€ ì—†ì§€ë§Œ, eslintì˜ ê²½ê³ ì˜€ë‹¤.

  ![eslint warning](/static/images/eslint.png) 

- ì´ê²Œ ë¬´ìŠ¨ ë§ì¸ì§€ ì´í•´ë¥¼ í•  ìˆ˜ê°€ ì—†ì–´, ë˜ ë‹¤ì‹œ ChatGPTì—ê²Œ ë¬¼ì–´ë´¤ì§€ë§Œ, ë§Œì¡±ìŠ¤ëŸ¬ìš´ ëŒ€ë‹µì„ ì–»ì„ ìˆ˜ ì—†ì—ˆë‹¤. ê·¸ë˜ì„œ ì´ë²ˆì—” êµ¬ê¸€ë§ì„ í•˜ì—¬ stackoverflowì—ì„œ í•´ê²°í•˜ì˜€ë‹¤! ğŸ‘ğŸ‘ğŸ‰ğŸ‰

  > [stackoverflow](https://stackoverflow.com/questions/69830440/react-hook-usecallback-received-a-function-whose-dependencies-are-unknown-pass)

  `useCallback`ëŒ€ì‹  `useMemo`Hookì„ ì‚¬ìš©í•˜ë¼ëŠ” ê²ƒì´ë‹¤. ì´ë¥¼ ì ìš©í•œ ìµœì¢… ì½”ë“œ.

  ```tsx
  import { useState, useRef, useEffect, useMemo } from 'react';
  import { imgUrl, requests } from './api/requests';
  import { Movie } from '.';
  import { axiosInstance } from './api/axios';
  import { AxiosError } from 'axios';
  import debounce from 'lodash.debounce';
  
  export default function Upcoming() {  
    const [movies, setMovies] = useState<Movie[]>([]);
    const [page, setPage] = useState<number>(0);
    const endPoint = requests.upComing;
  
    useEffect(() => {
      const fetchMovies = async () => {
        try {
          const res = await axiosInstance.get(`${endPoint}?page=${page}`);
          const newMovies = res.data.results;
  
          setMovies((prevMovies) => [...prevMovies, ...newMovies]);
        } catch (error) {
          const err = error as AxiosError;
          console.log(err.response?.data);
        }
      };
  
      fetchMovies();
    }, [page, endPoint]);
  
    const ref = useRef<HTMLDivElement>(null);
  
    const callback = useMemo(
      () =>
        debounce((entries: IntersectionObserverEntry[]) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              setPage((prevPage) => prevPage + 1);
            }
          });
        }, 500),
      [setPage]
    );
  
    useEffect(() => {
      if (!ref.current) return;
  
      const observer = new IntersectionObserver(callback);
      observer.observe(ref.current);
  
      return () => observer.disconnect();
    }, [callback]);
    
    return (
      <div className='space-y-3 p-8 bg-black'>
        <h1 className='text-white text-base md:text-2xl font-bold'>
          Upcoming Movies
        </h1>
        <div className='grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3'>
          {movies.map((movie, idx) => (
            <div key={idx} className='relative group cursor-pointer'>
              <img
                src={`${imgUrl}/w500${movie.backdrop_path || movie.poster_path}`}
                alt='Thumbnail'
                className='object-cover w-full rounded-md group-hover:opacity-50'
              />
              <h3 className='title opacity-0 group-hover:opacity-100 text-center absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-10 text-white font-bold'>
                {movie.title || movie.name}
              </h3>
            </div>
          ))}
          <div ref={ref} className='h-[1px]' />
        </div>
      </div>
    );
  }
  ```